#! %%PERL%%
##
#	SWISH++
#	searchc: search client
#
#	Copyright (C) 1999  Paul J. Lucas
#
#	This program is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; either version 2 of the License, or
#	(at your option) any later version.
# 
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
# 
#	You should have received a copy of the GNU General Public License
#	along with this program; if not, write to the Free Software
#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
##

$ConfigFile_Default = 'swish++.conf';
$ResultsMax_Default = 100;
$SocketFile_Default = '/tmp/search.socket';

########## You should't have to change anything below this line. ##############

##
# SEE ALSO
#
#	Larry Wall, et al.  "Programming Perl," 2nd ed., O'Reilly and
#	Associates, Inc., Sebestapol, CA, 1996, p. 73.
##

require 5.003;

use File::Basename;
use Getopt::Std;
use Socket;

$me = basename( $0 );
sub usage;

########## Process command-line options #######################################

( getopts( 'c:dDhm:Mr:sSu:Vw:' ) && !$opt_h ) || usage();

( $ConfigFile = $opt_c ) ||= $ConfigFile_Default;
$SocketFile = $SocketFile_Default;

##
# First, parse the config. file (if any); then override variables specified on
# the command line with options.
##
if ( open( CONF, $ConfigFile ) ) {
	my $conf = join( '', grep( !/^\s*#/, <CONF> ) );
	close( CONF );
	$conf =~ /SocketFile\s+(\S+)/im;
	$SocketFile = $1 if $1;
	$conf =~ /ResultsMax\s+(\S+)/im;
	$ResultsMax = $1 if $1;
} else {
	die "$me: could not read configuration \"$ConfigFile\"\n"
		if $ConfigFile ne $ConfigFile_Default;
}

$ResultsMax = $opt_m if $opt_m;
$SocketFile = $opt_u if $opt_u;

unshift( @ARGV, '-d' ) if $opt_d;
unshift( @ARGV, '-D' ) if $opt_D;
unshift( @ARGV, "-m$ResultsMax" ) if $ResultsMax;
unshift( @ARGV, '-M' ) if $opt_M;
unshift( @ARGV, "-r$opt_r" ) if $opt_r;
unshift( @ARGV, '-s' ) if $opt_s;
unshift( @ARGV, '-S' ) if $opt_S;
unshift( @ARGV, '-V' ) if $opt_V;
unshift( @ARGV, "-w$opt_w" ) if $opt_w;

########## Main ###############################################################

##
# Connect to the 'search' server via a Unix domain socket.  See [Wall], p. 353.
##
socket( SEARCH, PF_UNIX, SOCK_STREAM, 0 ) or
	die "$me: can not open socket: $!\n";
connect( SEARCH, sockaddr_un( $SocketFile ) ) or
	die "$me: can not connect to \"$SocketFile\": $!\n";

##
# We *MUST* set autoflush for the socket filehandle, otherwise the server
# thread will hang since I/O buffering will wait for the buffer to fill that
# will never happen since queries are short.  See [Wall], p. 130, 211.
##
my $old_fh = select( SEARCH ); $| = 1; select( $old_fh );

##
# We also *MUST* print a trailing newline since the server reads an entire line
# of input (so therefore it looks and waits for a newline).
##
print SEARCH 'search ', join( ' ', @ARGV ), "\n";	# send query to server

print while <SEARCH>;					# read results back
close( SEARCH );
exit 0;

########## Miscellaneous function(s) ##########################################

sub usage {
	die <<USAGE;
usage: $me [options] [query]
options:
========
-c config_file  : Name of configuration file [default: $ConfigFile_Default]
-d              : Dump query word indices and exit
-D              : Dump entire word index and exit
-h              : Print this help message
-m max_results  : Maximum number of results [default: $ResultsMax_Default]
-M              : Dump meta-name index and exit
-r skip_results : Number of initial results to skip [default: 0]
-s              : Stem words prior to search [default: no]
-S              : Dump stop-word index and exit
-u socket_file  : Name of socket file [default: $SocketFile_Default]
-V              : Print version number and exit
-w size[,chars] : Dump window of words around query words [default: 0]
USAGE
}
